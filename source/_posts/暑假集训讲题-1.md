---
title: 暑假集训讲题(1)
mathjax: true
date: 2021-07-26 23:39:38
tags:
---

## 关键词: 高等数学， 定积分
## 题目链接  
[自适应辛普森法1](https://www.luogu.com.cn/problem/P4525)  
[自适应辛普森法2](https://www.luogu.com.cn/problem/P4526)  
## 题目描述
计算定积分  
$$\int_l^r{ \frac{cx + d}{ax + b} dx}$$  
精确到小数点后六位。
## 题解
辛普森公式:
$$\int_l^rf(x)dx \approx simp(l, r)= \frac{f(l) + 4f(\frac{l+r}{2}) + f(r)}{6}(r-l)$$
但直接用这个公式显然精度不够，所以我们要把积分区间划分成很多小段，每个小段分别用辛普森公式求积分，然后累加起来。  
函数值变化快的地方分段应分的细，变化平缓的地方分段可以粗一些。具体应该怎么做呢？  
自适应辛普森法:  

- 首先确定一个精度eps, 一般要比题目小几个数量级，这里题目要求精确到6位小数，eps可以定为$10^{-9}$。  
- 计算$S = simp(l, r)$
- 计算$S_1 = simp(l, \frac{l+r}{2})$, $S_2 = simp(\frac{l+r}{2},r)$  
- 如果$S$ 和 $S_1+S_2$的差的绝对值小于eps,则用$S_1 + S_2$作为(l,r)区间上的积分值，否则递归计算$(l, \frac{l+r}{2})$和$(\frac{l+r}{2}, r)$两个区间.

## 代码:  
``` cpp
#include <cstdio>
#include <cmath>
using namespace std;
const double eps = 1e-9;
double a,b,c,d,L,R;


double f(double x){
	return (c*x+d)/(a*x+b);
}


double Simp(double l,double r){
	double mid = (l+r)/2;
	return (r-l)/6*( f(l)+f(r)+4*f(mid)  );
}

double work(double l,double r){
	double mid = (l+r)/2;
	double s1 = Simp(l,mid);
	double s2 = Simp(mid,r);
	double s = Simp(l,r);
	if(fabs(s1+s2-s) <eps ) return s1+s2;
	else return work(l,mid)+work(mid,r);
}

int main(){
	scanf("%lf%lf%lf%lf%lf%lf",&a,&b,&c,&d,&L,&R);
	printf("%.6lf\n",work(L,R)); 
	return 0;
}
```
