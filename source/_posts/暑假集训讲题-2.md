---
title: 暑假集训讲题(2)
mathjax: true
date: 2021-07-26 23:40:44
tags:
---
## 关键词 Trie, 字符串, 异或  
## Trie
Trie(字典树)是一种用于实现字符串快速检索的多叉树结构。 
Trie中每条边代表一个字符。每个节点代表一个字符串。
![Trie](3avofuin.png)
### 初始化
一棵空的Trie仅包含一个根节点。
### 播入、查询
![](1m6qufjy.png)

### 模板题  
[于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)

### 代码
``` cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 10000 + 100;

char s[55];
int trie[maxn * 55][26], root, tot;
int ed[maxn * 55];
bool vis[maxn];

void insert(char* s, int id) {
    int cur = root;
    int len = strlen(s);
    for (int i = 0; i < len; i++) {
        int v = s[i] - 'a';
        if (!trie[cur][v])
            trie[cur][v] = ++tot;
        cur = trie[cur][v];
    }
    ed[cur] = id;
}

void query(char* s) {
    int cur = root;
    int len = strlen(s);
    for (int i = 0; i < len; i++) {
        int v = s[i] - 'a';
        if (!trie[cur][v]) {
            printf("WRONG\n");
            return;
        }
        cur = trie[cur][v];
    }
    if(!ed[cur])
    	printf("WRONG\n");
    else if (vis[ed[cur]])
        printf("REPEAT\n");
    else {
        printf("OK\n");
        vis[ed[cur]] = true;
    }
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%s", s);
        insert(s, i);
    }
    int m;
    scanf("%d", &m);
    while (m--) {
        scanf("%s", s);
        query(s);
    }

    return 0;
}
```

## 01 Trie  
两道类似的题  
[The Xor Largest Pair](https://ac.nowcoder.com/acm/problem/50993)  
[Xor Sum](https://acm.hdu.edu.cn/showproblem.php?pid=6955)(第一场杭电多校)

### The xor largest pair
#### 题意
给出$A_i, A_2, A_3, ..., A_n$,$n$个数,任选两个数进行异或运算，最大的结果是多少。
#### 题解
把每个数转化为2进制字符串，建一棵Trie树。查询时，每次尽量向与该位不同的方向走。
``` cpp
#include <cstdio>
#include <algorithm>


using namespace std;
const int maxn = 1000000 + 10;

int ch[2 * maxn][2];
int tot;
int n;
int root;


void insert(int v) {
    int u = root;

    for (int i = 30; i >= 0; i--) {
        int t = (v >> i) & 1;
        if (!ch[u][t]) ch[u][t] = ++tot;
        u = ch[u][t];
    }

}

int query(int v) {
    int res = 0;
    int u = root;

    for (int i = 30; i >= 0; i--) {
        int t = (v >> i) & 1;

        if (ch[u][!t]) {
            u = ch[u][!t];
            res |= (1 << i);
        } else {
            u = ch[u][t];
        }

    }
    return res;
}

int main() {

    scanf("%d", &n);
    tot = 0;
    root = ++tot;

    int v;
    scanf("%d", &v);
    insert(v);
    int ans = 0;
    for (int i = 2; i <= n; i++) {
        scanf("%d", &v);
        ans = max(ans, query(v));
        insert(v);
    }
    printf("%d\n", ans);
    return 0;
}
```

### Xor Sum  
#### 题意
给一个长度为n的序列$a_1,a_2,...,a_n$，求长度最短的连续子区间[l, r]，使$[a_l \ xor \ a_{l+1} \ xor \ ... \ xor \ a_r]$不小于k.
#### 题解
先求异或前缀和， $S_i = a_1 \ xor \ ... \ xor \ a_i$,   
则区间$[l, r]$的异或值为$S_r \ xor\ S_{l-1}$  
则原问题变成了在$s_0, s_1, ..., s_n$中选两个数异或，使异或结果不小于k.可以用01Trie解决

``` cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 100000 * 31 + 100;
int trie[maxn][2], tot, root;
int n, k;
int a[maxn];

int ans, l;
int last[maxn];
void insert(int val, int id) {
    int cur = root;
    for (int i = 30; i >= 0; i--) {
        int v = val >> i & 1;
        if (trie[cur][v] == 0) {
            trie[cur][v] = ++tot;
        }
        cur = trie[cur][v];
        last[cur] = id;
    }
}

void query(int val, int id) {
    int t = 0;
    int cur = root;
    for (int i = 30; i >= 0; i--) {
        int v = val >> i & 1;
        if (trie[cur][!v]) {
            cur = trie[cur][!v];
            t |= 1 << i;
        } else
            cur = trie[cur][v];

        if (t >= k) {
            if (ans > id - last[cur] || ans == id - last[cur] && last[cur] < l) {
                ans = id - last[cur];
                l = last[cur];
            }
        }
    }
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        memset(trie, 0, sizeof(trie));

        tot = 0;
        root = ++tot;
        scanf("%d%d", &n, &k);
        for (int i = 1; i <= n; i++) {
            scanf("%d", &a[i]);
        }
        for (int i = 1; i <= n; i++) {
            a[i] ^= a[i - 1];
        }

        insert(0, 0);
        ans = n + 1, l = 0;

        for (int i = 1; i <= n; i++) {
            query(a[i], i);
            insert(a[i], i);
        }
        if (ans > n)
            printf("-1\n");
        else
            printf("%d %d\n", l + 1, l + ans);
    }

    return 0;
}
```