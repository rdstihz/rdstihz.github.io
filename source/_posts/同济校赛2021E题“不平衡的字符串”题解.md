---
title: 同济校赛2021E题“不平衡的字符串”题解
mathjax: true
date: 2021-05-29 23:16:56
tags:
---

## 题目大意
题目链接https://ac.nowcoder.com/acm/contest/16832/E  
给出一个长度为$n$的字符串$S$,以及$m$个约束。第i个约束要求字符串中字符$s_i$的个数与串长之比$k$满足$\frac{a}{b} < k \le \frac{c}{d}$。保证$\frac{1}{2} \le \frac{a}{b} < \frac{c}{d} \le 1$。    
求$S$的所有子串中，至少满足一个约束的子串的个数。    
$S$中只含有小写字母。    
对于同一个字符，不会出现多个约束。    
## 题解
因为$\frac{a}{b} \ge \frac{1}{2}$，所以不可能有一个子串同时满足多个约束条件。因此，只需要对依次考虑每个约束条件，求出满足的子串个数，再累加即可。  

考虑一个约束条件, 要求串中字符$s_i$的比例$k$大于$\frac{a}{b}$，小于等于$\frac{c}{d}$。 只需分别求出满足$k \le \frac{c}{d}$或$k \le \frac{a}{b}$的子串的个数，相减即可得到满足这个约束条件的子串个数。  
现在考虑如何求满足$k \le \frac{a}{b}$的子串个数。用$p_i$表示字符串$S$的前$i$位中字符$s_i$的个数。则$S$的任意一个子串中字符$s_i$的比例可以写成  
$$ k = \frac{p_j - p_{i - 1}}{j - (i - 1)} \le \frac{a}{b} $$  
化简可得  
$$ aj - b p_j \ge a(i - 1) - b * p_{i - 1} $$  
设$g_i = a_i - bp_i$, 则上式可以写成$b_j \ge b_{i - 1}$ 
所以，只需要求满足$i \le j$并且$b_j \ge b_{i - 1}$的$(i,j)$的对数。可用类似数状数组求逆序对的方法求解。


## 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 50000 + 100;

char s[maxn];
int p[maxn];

int n;

struct Tree {
    inline int lowbit(int x) {
        return x & -x;
    }
    int C[maxn];

    void add(int p) {
        for (; p <= n; p += lowbit(p))
            C[p]++;
    }

    int sum(int p) {
        int res = 0;
        for (; p; p -= lowbit(p))
            res += C[p];
        return res;
    }

} T1, T2;

int val1[maxn], val2[maxn];
vector<int> nums;

int main() {

    scanf("%d", &n);
    scanf("%s", s + 1);

    int m;
    scanf("%d", &m);
    char ch;
    int a, b, c, d;

    long long ans = 0;
    while (m--) {
        getchar();

        //printf("hehe\n");
        scanf("%c%d%d%d%d", &ch, &a, &b, &c, &d);

        for (int i = 1; i <= n; i++)
            p[i] = p[i - 1] + (s[i] == ch);

        // val1[i] = ai - b * p[i] , 离散化
        for (int i = 0; i <= n; i++) {
            val1[i] = a * i - b * p[i];
            nums.push_back(val1[i]);
        }
        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        for (int i = 0; i <= n; i++)
            val1[i] = lower_bound(nums.begin(), nums.end(), val1[i]) - nums.begin() + 1;
        nums.clear();
        //printf("hehe1\n");

        // val2[i] = ci - d * p[i]
        for (int i = 0; i <= n; i++) {
            val2[i] = c * i - d * p[i];
            nums.push_back(val2[i]);
        }

        sort(nums.begin(), nums.end());
        nums.erase(unique(nums.begin(), nums.end()), nums.end());
        for (int i = 0; i <= n; i++)
            val2[i] = lower_bound(nums.begin(), nums.end(), val2[i]) - nums.begin() + 1;
        nums.clear();
        //printf("hehe2\n");

        // for (int i = 1; i <= n; i++)
        //     printf("%d ", val1[i]);
        // printf("\n");

        // for (int i = 1; i <= n; i++)
        //     printf("%d ", val2[i]);
        // printf("\n");

        memset(T1.C, 0, 4 * maxn);
        memset(T2.C, 0, 4 * maxn);
        T1.add(val1[0]);
        T2.add(val2[0]);
        for (int i = 1; i <= n; i++) {
            int t1 = T1.sum(val1[i]);
            int t2 = T2.sum(val2[i]);
            ans += t2 - t1;
            T1.add(val1[i]);
            T2.add(val2[i]);
        }
        //cout << ans << endl;
    }

    printf("%lld\n", ans);

    return 0;
}
```